// Generated by CoffeeScript 1.3.3
var UILoop, accessors, bind, chain, emmiter, int, surface, uid, _ref, _ref1;

_ref = require('tools/object'), bind = _ref.bind, chain = _ref.chain, accessors = _ref.accessors, emmiter = _ref.emmiter;

_ref1 = require('utils'), uid = _ref1.uniqueId, UILoop = _ref1.UILoop;

int = function(string) {
  return parseInt(string, 10) || 0;
};

surface = {
  _el: null,
  _target: null,
  _clicked: false,
  _offsetX: 0,
  _offsetY: 0,
  _elements: [],
  create: function() {
    var instance;
    instance = chain(Object.create(this)).use(emmiter).use(accessors, ['width', 'height'], true).and(bind, ['_mouseDown', '_mouseUp', '_mouseMove']);
    instance._clicked = false;
    instance._elements = [];
    instance.scrollLeft = 0;
    instance.scrollTop = 0;
    return instance;
  },
  _isClicked: function(e) {
    var node;
    if (!e) {
      return false;
    }
    node = e.target || e;
    if (node === this._el) {
      return true;
    }
    return this._isClicked(node.parentNode);
  },
  _listeners: function(target, action) {
    if (action == null) {
      action = 'add';
    }
    target["" + action + "EventListener"]('mouseleave', this._mouseUp);
    target["" + action + "EventListener"]('mouseup', this._mouseUp);
    return target["" + action + "EventListener"]('mousemove', this._mouseMove);
  },
  _updateOffsets: function() {
    this.scrollTop = window.pageYOffset - document.documentElement.clientTop;
    return this.scrollLeft = window.pageXOffset - document.documentElement.clientLeft;
  },
  _mouseDown: function(e) {
    var clicked;
    this._listeners(document.body, 'add');
    clicked = this._clicked = this._isClicked(e);
    if (clicked) {
      this._updateOffsets();
      return this.emit('mousedown', this._formatEvent(e));
    }
  },
  _formatEvent: function(e) {
    var target, x, y;
    x = this.x = (e.x - this._offsetX) + this.scrollLeft;
    y = this.y = (e.y - this._offsetY) + this.scrollTop;
    target = this.target = e.target;
    this.which = e.which;
    return {
      x: x,
      y: y,
      target: target,
      originalEvent: e
    };
  },
  _mouseMove: function(e) {
    if (this._clicked) {
      return this.emit('mousemove', this._formatEvent(e));
    }
  },
  _mouseUp: function(e) {
    this._clicked = false;
    this.emit('mouseup', e);
    return this._listeners(document.body, 'remove');
  },
  _offsets: function(styles, which) {
    var b, m, p;
    m = int(styles["margin-" + which]);
    p = int(styles["padding-" + which]);
    b = int(styles["border-" + which + "-width"]);
    return {
      m: m,
      b: b,
      p: p
    };
  },
  select: function(selector) {
    var bb, bl, br, bt, clientRect, el, mb, ml, mr, mt, pb, pl, pr, pt, styles, _ref2, _ref3, _ref4, _ref5;
    if (selector == null) {
      selector = null;
    }
    if (!selector) {
      return new Error('An element querySelector must be specified.');
    }
    el = document.querySelector(selector);
    el.innerHTML = '';
    el.addEventListener('mousedown', this._mouseDown);
    styles = window.getComputedStyle(el);
    clientRect = el.getBoundingClientRect();
    _ref2 = this._offsets(styles, 'top'), mt = _ref2.m, bt = _ref2.b, pt = _ref2.p;
    _ref3 = this._offsets(styles, 'right'), mr = _ref3.m, br = _ref3.b, pr = _ref3.p;
    _ref4 = this._offsets(styles, 'bottom'), mb = _ref4.m, bb = _ref4.b, pb = _ref4.p;
    _ref5 = this._offsets(styles, 'left'), ml = _ref5.m, bl = _ref5.b, pl = _ref5.p;
    this._offsetX = clientRect.left + (ml + bl + pl);
    this._offsetY = clientRect.top + (mt + bt + pt);
    this.width(clientRect.width - ((bl + pl) + (br + pr)));
    this.height(clientRect.height - ((bt + pt) + (bb + pb)));
    this._el = el;
    this._target = el;
    return this;
  },
  draw: function(el) {
    el.id(el.id() || uid() + 1);
    el._load(this);
    this._elements.push(el);
    return this;
  },
  update: function(changes) {
    this._elements.forEach(function(e) {
      return e.draw(changes, true);
    });
  },
  "delete": function(el) {
    var els, g, idx;
    els = this._elements;
    idx = this._elements.indexOf(el);
    if (!!~idx) {
      el._listeners(this, 'remove');
      g = el._$g[0][0];
      g.parentNode.removeChild(g);
      return els.splice(idx, 1);
    }
  }
};

module.exports = surface;
